/**
 * Book Inventory Management System - Google Apps Script
 * This script handles form submissions and search queries for the Book Inventory application
 *
 * Google Sheet Structure Required:
 *
 * Book_Registry Sheet:
 * Column A: BookTitle
 * Column B: Author
 * Column C: Genre
 * Column D: Category
 * Column E: ContactPerson
 * Column F: ContactNumber
 * Column G: UnitNo
 * Column H: Language
 *
 * ISBN_List Sheet:
 * Column A: ISBN
 * Column B: BookTitle
 * Column C: Authors
 * Column D: Publisher
 * Column E: PublishedDate
 * Column F: Categories
 */

// Configuration
const SHEET_NAME = 'Book_Registry'; // Change this to match your sheet name if different
const ISBN_SHEET_NAME = 'ISBN_List'; // Sheet for scanned ISBN books
const SPREADSHEET_ID = '1MsfdeZrWk7dYU-D0jjRYmUPb8Q_eY1kCMsx4YXwW_i0';

/**
 * Handle GET requests - Retrieve all books or search
 */
function doGet(e) {
  try {
    const sheet = getSheet();

    // Check if search parameter exists
    if (e.parameter.search) {
      return searchBooks(e.parameter.search, sheet);
    }

    // Return all books
    return getAllBooks(sheet);

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error processing request: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Handle POST requests - Add or delete books
 */
function doPost(e) {
  try {
    const params = JSON.parse(e.postData.contents);
    const sheet = getSheet();

    // Route to appropriate action
    switch(params.action) {
      case 'add':
        return addBook(params, sheet);
      case 'delete':
        return deleteBook(params, sheet);
      case 'update':
        return updateBook(params, sheet);
      case 'search':
        return searchBooks(params.searchTerm, sheet);
      case 'addISBN':
        return addISBN(params);
      case 'getISBNList':
        return getISBNList();
      case 'saveToBookRegistry':
        return saveToBookRegistry(params, sheet);
      case 'bulkSaveToBookRegistry':
        return bulkSaveToBookRegistry(params, sheet);
      default:
        return createResponse({
          success: false,
          message: 'Unknown action: ' + params.action
        });
    }

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error processing request: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Get the active sheet
 */
function getSheet() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  let sheet = ss.getSheetByName(SHEET_NAME);

  // If sheet doesn't exist, try the first sheet
  if (!sheet) {
    sheet = ss.getSheets()[0];
  }

  return sheet;
}

/**
 * Get all books from the sheet
 */
function getAllBooks(sheet) {
  const data = sheet.getDataRange().getValues();

  if (data.length <= 1) {
    return createResponse({
      success: true,
      data: [],
      count: 0,
      message: 'No books found in inventory'
    });
  }

  const headers = data[0];
  const rows = data.slice(1);

  // Convert rows to objects
  const books = rows.map(row => {
    let book = {};
    headers.forEach((header, index) => {
      book[header] = row[index];
    });
    return book;
  }).filter(book => {
    // Filter out empty rows
    return book['BookTitle'] && book['BookTitle'].toString().trim() !== '';
  });

  return createResponse({
    success: true,
    data: books,
    count: books.length,
    message: `Retrieved ${books.length} books successfully`
  });
}

/**
 * Add a new book to the inventory
 */
function addBook(params, sheet) {
  // Validate required fields
  const requiredFields = ['bookTitle', 'author', 'genre', 'category', 'contactPerson', 'contactNumber', 'unitNo', 'language'];
  const missingFields = requiredFields.filter(field => !params[field]);

  if (missingFields.length > 0) {
    return createResponse({
      success: false,
      message: 'Missing required fields: ' + missingFields.join(', ')
    });
  }

  // Check if book with same title and author already exists
  const existingBooks = getAllBooks(sheet);
  if (existingBooks.success) {
    const duplicate = existingBooks.data.find(book =>
      book['BookTitle'].toString().toLowerCase() === params.bookTitle.toString().toLowerCase() &&
      book['Author'].toString().toLowerCase() === params.author.toString().toLowerCase()
    );

    if (duplicate) {
      return createResponse({
        success: false,
        message: 'A book with title "' + params.bookTitle + '" by "' + params.author + '" already exists'
      });
    }
  }

  // Append the row with book data (no timestamp)
  sheet.appendRow([
    params.bookTitle,    // Column A: BookTitle
    params.author,       // Column B: Author
    params.genre,        // Column C: Genre
    params.category,     // Column D: Category
    params.contactPerson,// Column E: ContactPerson
    params.contactNumber,// Column F: ContactNumber
    params.unitNo,       // Column G: UnitNo
    params.language      // Column H: Language
  ]);

  return createResponse({
    success: true,
    message: 'Book "' + params.bookTitle + '" added successfully',
    data: {
      bookTitle: params.bookTitle,
      author: params.author
    }
  });
}

/**
 * Delete a book from the inventory
 */
function deleteBook(params, sheet) {
  if (!params.bookTitle || !params.author) {
    return createResponse({
      success: false,
      message: 'Book Title and Author are required for deletion'
    });
  }

  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const bookTitleColumnIndex = headers.indexOf('BookTitle');
  const authorColumnIndex = headers.indexOf('Author');

  if (bookTitleColumnIndex === -1 || authorColumnIndex === -1) {
    return createResponse({
      success: false,
      message: 'Required columns not found in sheet'
    });
  }

  // Find the row to delete (start from row 2, skip header)
  for (let i = 1; i < data.length; i++) {
    if (data[i][bookTitleColumnIndex].toString().toLowerCase() === params.bookTitle.toString().toLowerCase() &&
        data[i][authorColumnIndex].toString().toLowerCase() === params.author.toString().toLowerCase()) {

      // Log the deletion to Delete_Log sheet before deleting
      try {
        logDeletion(data[i], headers, sheet.getParent());
      } catch (logError) {
        Logger.log('Error logging deletion: ' + logError.message);
        // Continue with deletion even if logging fails
      }

      sheet.deleteRow(i + 1); // +1 because sheets are 1-indexed
      return createResponse({
        success: true,
        message: 'Book "' + params.bookTitle + '" by "' + params.author + '" deleted successfully'
      });
    }
  }

  return createResponse({
    success: false,
    message: 'Book "' + params.bookTitle + '" by "' + params.author + '" not found'
  });
}

/**
 * Log deleted book to Delete_Log sheet
 */
function logDeletion(bookRow, headers, spreadsheet) {
  // Get or create Delete_Log sheet
  let deleteLogSheet = spreadsheet.getSheetByName('Delete_Log');

  if (!deleteLogSheet) {
    // Create the sheet if it doesn't exist
    deleteLogSheet = spreadsheet.insertSheet('Delete_Log');

    // Add headers to the new sheet
    const logHeaders = headers.concat(['DeletedTimestamp']);
    deleteLogSheet.appendRow(logHeaders);

    // Format the header row
    const headerRange = deleteLogSheet.getRange(1, 1, 1, logHeaders.length);
    headerRange.setBackground('#8b7355');
    headerRange.setFontColor('#f5f1e8');
    headerRange.setFontWeight('bold');
  }

  // Add timestamp to the book data
  const timestamp = new Date();
  const formattedTimestamp = Utilities.formatDate(timestamp, Session.getScriptTimeZone(), 'MM-dd-yyyy HH:mm:ss');

  // Append the deleted book data with timestamp
  const logData = bookRow.concat([formattedTimestamp]);
  deleteLogSheet.appendRow(logData);
}

/**
 * Update an existing book
 */
function updateBook(params, sheet) {
  if (!params.bookTitle || !params.author) {
    return createResponse({
      success: false,
      message: 'Book Title and Author are required for update'
    });
  }

  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const bookTitleColumnIndex = headers.indexOf('BookTitle');
  const authorColumnIndex = headers.indexOf('Author');

  if (bookTitleColumnIndex === -1 || authorColumnIndex === -1) {
    return createResponse({
      success: false,
      message: 'Required columns not found in sheet'
    });
  }

  // Find the row to update
  for (let i = 1; i < data.length; i++) {
    if (data[i][bookTitleColumnIndex].toString().toLowerCase() === params.bookTitle.toString().toLowerCase() &&
        data[i][authorColumnIndex].toString().toLowerCase() === params.author.toString().toLowerCase()) {
      const rowNumber = i + 1;

      // Update the fields that are provided
      if (params.genre !== undefined) {
        const genreIndex = headers.indexOf('Genre');
        if (genreIndex !== -1) sheet.getRange(rowNumber, genreIndex + 1).setValue(params.genre);
      }
      if (params.category !== undefined) {
        const categoryIndex = headers.indexOf('Category');
        if (categoryIndex !== -1) sheet.getRange(rowNumber, categoryIndex + 1).setValue(params.category);
      }
      if (params.contactPerson !== undefined) {
        const contactPersonIndex = headers.indexOf('ContactPerson');
        if (contactPersonIndex !== -1) sheet.getRange(rowNumber, contactPersonIndex + 1).setValue(params.contactPerson);
      }
      if (params.contactNumber !== undefined) {
        const contactNumberIndex = headers.indexOf('ContactNumber');
        if (contactNumberIndex !== -1) sheet.getRange(rowNumber, contactNumberIndex + 1).setValue(params.contactNumber);
      }
      if (params.unitNo !== undefined) {
        const unitNoIndex = headers.indexOf('UnitNo');
        if (unitNoIndex !== -1) sheet.getRange(rowNumber, unitNoIndex + 1).setValue(params.unitNo);
      }
      if (params.language !== undefined) {
        const languageIndex = headers.indexOf('Language');
        if (languageIndex !== -1) sheet.getRange(rowNumber, languageIndex + 1).setValue(params.language);
      }

      return createResponse({
        success: true,
        message: 'Book "' + params.bookTitle + '" updated successfully'
      });
    }
  }

  return createResponse({
    success: false,
    message: 'Book "' + params.bookTitle + '" by "' + params.author + '" not found'
  });
}

/**
 * Search books by multiple criteria
 */
function searchBooks(searchTerm, sheet) {
  if (!searchTerm || searchTerm.trim() === '') {
    return createResponse({
      success: false,
      message: 'Search term is required'
    });
  }

  const allBooksResponse = getAllBooks(sheet);

  if (!allBooksResponse.success || allBooksResponse.data.length === 0) {
    return createResponse({
      success: true,
      data: [],
      count: 0,
      message: 'No books found in inventory'
    });
  }

  const searchWords = searchTerm.toLowerCase().trim().split(/\s+/);

  // Filter books that match all search words in any field
  const filteredBooks = allBooksResponse.data.filter(book => {
    const searchableText = [
      book['BookTitle'],
      book['Author'],
      book['Genre'],
      book['Category'],
      book['ContactPerson'],
      book['ContactNumber'],
      book['UnitNo'],
      book['Language']
    ].join(' ').toLowerCase();

    return searchWords.every(word => searchableText.includes(word));
  });

  return createResponse({
    success: true,
    data: filteredBooks,
    count: filteredBooks.length,
    searchTerm: searchTerm,
    message: `Found ${filteredBooks.length} book(s) matching "${searchTerm}"`
  });
}

/**
 * Get statistics about the inventory
 */
function getStatistics() {
  try {
    const sheet = getSheet();
    const allBooksResponse = getAllBooks(sheet);

    if (!allBooksResponse.success) {
      return createResponse({
        success: false,
        message: 'Failed to retrieve books for statistics'
      });
    }

    const books = allBooksResponse.data;

    // Calculate statistics
    const stats = {
      totalBooks: books.length,
      uniqueAuthors: new Set(),
      uniqueGenres: new Set(),
      uniqueCategories: new Set(),
      uniqueContactPersons: new Set(),
      uniqueUnits: new Set()
    };

    books.forEach(book => {
      if (book['Author']) stats.uniqueAuthors.add(book['Author'].trim());
      if (book['Genre']) stats.uniqueGenres.add(book['Genre'].trim());
      if (book['Category']) stats.uniqueCategories.add(book['Category'].trim());
      if (book['ContactPerson']) stats.uniqueContactPersons.add(book['ContactPerson'].trim());
      if (book['UnitNo']) stats.uniqueUnits.add(book['UnitNo'].trim());
    });

    stats.uniqueAuthorsCount = stats.uniqueAuthors.size;
    stats.uniqueGenresCount = stats.uniqueGenres.size;
    stats.uniqueCategoriesCount = stats.uniqueCategories.size;
    stats.uniqueContactPersonsCount = stats.uniqueContactPersons.size;
    stats.uniqueUnitsCount = stats.uniqueUnits.size;

    // Convert sets to arrays for JSON
    stats.uniqueAuthors = Array.from(stats.uniqueAuthors);
    stats.uniqueGenres = Array.from(stats.uniqueGenres);
    stats.uniqueCategories = Array.from(stats.uniqueCategories);
    stats.uniqueContactPersons = Array.from(stats.uniqueContactPersons);
    stats.uniqueUnits = Array.from(stats.uniqueUnits);

    return createResponse({
      success: true,
      data: stats,
      message: 'Statistics retrieved successfully'
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error calculating statistics: ' + error.message
    });
  }
}

/**
 * Get books by category
 */
function getBooksByCategory(category) {
  try {
    const sheet = getSheet();
    const allBooksResponse = getAllBooks(sheet);

    if (!allBooksResponse.success) {
      return createResponse({
        success: false,
        message: 'Failed to retrieve books'
      });
    }

    const filteredBooks = allBooksResponse.data.filter(book =>
      book['Category'] && book['Category'].toString().toLowerCase() === category.toLowerCase()
    );

    return createResponse({
      success: true,
      data: filteredBooks,
      count: filteredBooks.length,
      message: `Found ${filteredBooks.length} books in category "${category}"`
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error retrieving books by category: ' + error.message
    });
  }
}

/**
 * Get books by genre
 */
function getBooksByGenre(genre) {
  try {
    const sheet = getSheet();
    const allBooksResponse = getAllBooks(sheet);

    if (!allBooksResponse.success) {
      return createResponse({
        success: false,
        message: 'Failed to retrieve books'
      });
    }

    const filteredBooks = allBooksResponse.data.filter(book =>
      book['Genre'] && book['Genre'].toString().toLowerCase() === genre.toLowerCase()
    );

    return createResponse({
      success: true,
      data: filteredBooks,
      count: filteredBooks.length,
      message: `Found ${filteredBooks.length} books in genre "${genre}"`
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error retrieving books by genre: ' + error.message
    });
  }
}

/**
 * Get books by contact person
 */
function getBooksByContact(contactPerson) {
  try {
    const sheet = getSheet();
    const allBooksResponse = getAllBooks(sheet);

    if (!allBooksResponse.success) {
      return createResponse({
        success: false,
        message: 'Failed to retrieve books'
      });
    }

    const filteredBooks = allBooksResponse.data.filter(book =>
      book['ContactPerson'] && book['ContactPerson'].toString().toLowerCase().includes(contactPerson.toLowerCase())
    );

    return createResponse({
      success: true,
      data: filteredBooks,
      count: filteredBooks.length,
      message: `Found ${filteredBooks.length} books for contact "${contactPerson}"`
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error retrieving books by contact: ' + error.message
    });
  }
}

/**
 * Format timestamp in MM-DD-YY HH:mm:ss format
 */
function formatTimestamp(date) {
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const year = String(date.getFullYear()).slice(-2);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${month}-${day}-${year} ${hours}:${minutes}:${seconds}`;
}

/**
 * Create a standardized JSON response
 */
function createResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Add ISBN scanned book to ISBN_List sheet
 */
function addISBN(params) {
  try {
    // Validate required fields
    const requiredFields = ['isbn', 'bookTitle'];
    const missingFields = requiredFields.filter(field => !params[field]);

    if (missingFields.length > 0) {
      return createResponse({
        success: false,
        message: 'Missing required fields: ' + missingFields.join(', ')
      });
    }

    // Get or create ISBN_List sheet
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let isbnSheet = ss.getSheetByName(ISBN_SHEET_NAME);

    if (!isbnSheet) {
      // Create the sheet if it doesn't exist
      isbnSheet = ss.insertSheet(ISBN_SHEET_NAME);

      // Add headers
      const headers = ['ISBN', 'BookTitle', 'Authors', 'Publisher', 'PublishedDate', 'Categories'];
      isbnSheet.appendRow(headers);

      // Format header row
      const headerRange = isbnSheet.getRange(1, 1, 1, headers.length);
      headerRange.setBackground('#2e8b57');
      headerRange.setFontColor('#f5f1e8');
      headerRange.setFontWeight('bold');
    }

    // Check if ISBN already exists
    const data = isbnSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      if (data[i][0].toString() === params.isbn.toString()) {
        return createResponse({
          success: false,
          message: 'ISBN ' + params.isbn + ' already exists in ISBN_List'
        });
      }
    }

    // Append the ISBN data
    isbnSheet.appendRow([
      params.isbn,           // Column A: ISBN
      params.bookTitle,      // Column B: BookTitle
      params.authors || '',  // Column C: Authors
      params.publisher || '',// Column D: Publisher
      params.publishedDate || '', // Column E: PublishedDate
      params.categories || ''     // Column F: Categories
    ]);

    return createResponse({
      success: true,
      message: 'Book with ISBN ' + params.isbn + ' added to ISBN_List successfully',
      data: {
        isbn: params.isbn,
        bookTitle: params.bookTitle
      }
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error adding ISBN: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Get all ISBN_List entries
 */
function getISBNList() {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    let isbnSheet = ss.getSheetByName(ISBN_SHEET_NAME);

    // If sheet doesn't exist, return empty list
    if (!isbnSheet) {
      return createResponse({
        success: true,
        message: 'ISBN_List sheet does not exist yet',
        data: []
      });
    }

    // Get all data from sheet
    const dataRange = isbnSheet.getDataRange();
    const values = dataRange.getValues();

    // If only headers or empty, return empty list
    if (values.length <= 1) {
      return createResponse({
        success: true,
        message: 'ISBN_List is empty',
        data: []
      });
    }

    // Convert to array of objects (skip header row)
    const headers = values[0];
    const books = [];

    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      books.push({
        isbn: row[0] || '',
        bookTitle: row[1] || '',
        authors: row[2] || '',
        publisher: row[3] || '',
        publishedDate: row[4] || '',
        categories: row[5] || ''
      });
    }

    return createResponse({
      success: true,
      message: 'Retrieved ' + books.length + ' books from ISBN_List',
      data: books
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error retrieving ISBN_List: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Save book from ISBN_List to Book_Registry and remove from ISBN_List
 */
function saveToBookRegistry(params, sheet) {
  try {
    // Validate required fields
    const requiredFields = ['isbn', 'bookTitle', 'author', 'contactPerson', 'contactNumber', 'unitNo'];
    const missingFields = requiredFields.filter(field => !params[field]);

    if (missingFields.length > 0) {
      return createResponse({
        success: false,
        message: 'Missing required fields: ' + missingFields.join(', ')
      });
    }

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

    // Add to Book_Registry
    const registrySheet = sheet || ss.getSheetByName(SHEET_NAME);
    if (!registrySheet) {
      return createResponse({
        success: false,
        message: 'Book_Registry sheet not found'
      });
    }

    // Check if book already exists in Book_Registry
    const registryData = registrySheet.getDataRange().getValues();
    for (let i = 1; i < registryData.length; i++) {
      if (registryData[i][0].toString().toLowerCase() === params.bookTitle.toString().toLowerCase()) {
        return createResponse({
          success: false,
          message: 'Book "' + params.bookTitle + '" already exists in Book Registry'
        });
      }
    }

    // Append to Book_Registry
    // Columns: BookTitle, Author, Genre, Category, ContactPerson, ContactNumber, UnitNo, Language
    registrySheet.appendRow([
      params.bookTitle,           // Column A: BookTitle
      params.author,              // Column B: Author
      params.genre || '',         // Column C: Genre
      params.category || '',      // Column D: Category
      params.contactPerson,       // Column E: ContactPerson
      params.contactNumber,       // Column F: ContactNumber
      params.unitNo,              // Column G: UnitNo
      params.language || ''       // Column H: Language
    ]);

    // Remove from ISBN_List
    const isbnSheet = ss.getSheetByName(ISBN_SHEET_NAME);
    if (isbnSheet) {
      const isbnData = isbnSheet.getDataRange().getValues();
      for (let i = 1; i < isbnData.length; i++) {
        if (isbnData[i][0].toString() === params.isbn.toString()) {
          isbnSheet.deleteRow(i + 1);
          break;
        }
      }
    }

    return createResponse({
      success: true,
      message: 'Book "' + params.bookTitle + '" saved to Book Registry and removed from ISBN List',
      data: {
        bookTitle: params.bookTitle,
        isbn: params.isbn
      }
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error saving to Book Registry: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Bulk save all books from ISBN_List to Book_Registry and clear ISBN_List
 */
function bulkSaveToBookRegistry(params, sheet) {
  try {
    // Validate required fields
    if (!params.books || !Array.isArray(params.books) || params.books.length === 0) {
      return createResponse({
        success: false,
        message: 'No books provided for bulk save'
      });
    }

    const requiredFields = ['contactPerson', 'contactNumber', 'unitNo'];
    const missingFields = requiredFields.filter(field => !params[field]);

    if (missingFields.length > 0) {
      return createResponse({
        success: false,
        message: 'Missing required fields: ' + missingFields.join(', ')
      });
    }

    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const registrySheet = sheet || ss.getSheetByName(SHEET_NAME);

    if (!registrySheet) {
      return createResponse({
        success: false,
        message: 'Book_Registry sheet not found'
      });
    }

    // Get existing data to check for duplicates
    const registryData = registrySheet.getDataRange().getValues();
    const existingTitles = new Set();
    for (let i = 1; i < registryData.length; i++) {
      existingTitles.add(registryData[i][0].toString().toLowerCase());
    }

    let savedCount = 0;
    let skippedCount = 0;
    const skippedBooks = [];

    // Process each book
    params.books.forEach(book => {
      const bookTitleLower = (book.bookTitle || '').toString().toLowerCase();

      // Skip if already exists
      if (existingTitles.has(bookTitleLower)) {
        skippedCount++;
        skippedBooks.push(book.bookTitle);
        return;
      }

      // Add to Book_Registry
      // Columns: BookTitle, Author, Genre, Category, ContactPerson, ContactNumber, UnitNo, Language
      registrySheet.appendRow([
        book.bookTitle || '',        // Column A: BookTitle
        book.author || '',            // Column B: Author
        book.genre || '',             // Column C: Genre
        book.category || '',          // Column D: Category
        params.contactPerson,         // Column E: ContactPerson
        params.contactNumber,         // Column F: ContactNumber
        params.unitNo,                // Column G: UnitNo
        params.language || ''         // Column H: Language
      ]);

      savedCount++;
      existingTitles.add(bookTitleLower); // Add to set to prevent duplicates within the same batch
    });

    // Clear the entire ISBN_List sheet
    const isbnSheet = ss.getSheetByName(ISBN_SHEET_NAME);
    if (isbnSheet) {
      const lastRow = isbnSheet.getLastRow();
      if (lastRow > 1) {
        // Delete all rows except the header
        isbnSheet.deleteRows(2, lastRow - 1);
      }
    }

    let message = `Successfully saved ${savedCount} book(s) to Book Registry.`;
    if (skippedCount > 0) {
      message += ` ${skippedCount} book(s) were skipped (already exist).`;
    }
    message += ' ISBN_List has been cleared.';

    return createResponse({
      success: true,
      message: message,
      data: {
        savedCount: savedCount,
        skippedCount: skippedCount,
        skippedBooks: skippedBooks
      }
    });

  } catch (error) {
    return createResponse({
      success: false,
      message: 'Error bulk saving to Book Registry: ' + error.message,
      error: error.toString()
    });
  }
}

/**
 * Test function - Run this to verify the script works
 */
function testScript() {
  Logger.log('Testing Book Inventory Script...');

  // Test getting all books
  const allBooks = getAllBooks(getSheet());
  Logger.log('Get All Books:');
  Logger.log(allBooks.getContent());

  // Test statistics
  const stats = getStatistics();
  Logger.log('Statistics:');
  Logger.log(stats.getContent());
}
