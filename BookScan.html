<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Camera permissions -->
    <meta http-equiv="Permissions-Policy" content="camera=(self), microphone=(self)">
    <meta http-equiv="Feature-Policy" content="camera 'self'; microphone 'self'">

    <title>Book Barcode Scanner</title>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            color: #2e8b57;
            text-align: center;
            margin-bottom: 10px;
            font-size: 32px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .info-box {
            background-color: #e7f3ff;
            padding: 18px;
            border-left: 5px solid #2196F3;
            margin-bottom: 20px;
            border-radius: 6px;
        }

        .warning-box {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            padding: 25px;
            margin-bottom: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(238, 90, 111, 0.3);
            border: 3px solid #ff5252;
            display: none;
        }

        .warning-box h2 {
            color: white;
            margin-top: 0;
            font-size: 24px;
            text-align: center;
        }

        .warning-box p {
            color: white;
            margin: 15px 0;
            text-align: center;
            font-size: 16px;
            line-height: 1.6;
        }

        .btn {
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #2e8b57 0%, #3cb371 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(46, 139, 87, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-warning {
            background: white;
            color: #ff5252;
            padding: 20px 50px;
            font-size: 20px;
        }

        .btn-warning:hover {
            transform: scale(1.05);
        }

        #cameraViewContainer {
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            display: none;
        }

        #reader {
            width: 100%;
            border: 2px solid #2e8b57;
            border-radius: 10px;
        }

        #scanStatus {
            margin-top: 10px;
            background: #e7f3ff;
            color: #2196F3;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
            border-left: 4px solid #2196F3;
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        #scannedBookDetails {
            display: none;
            background-color: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #2e8b57;
            margin-bottom: 20px;
        }

        #scannedBookDetails h3 {
            color: #2e8b57;
            margin-bottom: 20px;
        }

        .detail-item {
            margin-bottom: 15px;
        }

        .detail-item strong {
            color: #5d4e37;
            display: block;
            margin-bottom: 5px;
        }

        .detail-item p {
            margin: 0;
            font-size: 16px;
        }

        #historyList {
            display: grid;
            gap: 10px;
        }

        .history-item {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2e8b57;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 10000;
            max-width: 400px;
            display: none;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border-left: 5px solid #28a745;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border-left: 5px solid #dc3545;
        }

        /* ISBN List Section */
        #isbnListSection {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #2e8b57;
        }

        #isbnListSection h3 {
            color: #2e8b57;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .refresh-grid-btn {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .refresh-grid-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.4);
        }

        /* Table Styles */
        .isbn-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .isbn-table thead {
            background: linear-gradient(135deg, #2e8b57 0%, #3cb371 100%);
            color: white;
        }

        .isbn-table th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .isbn-table td {
            padding: 15px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
            color: #333;
        }

        .isbn-table tbody tr {
            transition: all 0.3s ease-in-out;
        }

        .isbn-table tbody tr:hover {
            background: #f8f9fa;
            transform: scale(1.01);
        }

        .isbn-table tbody tr {
            opacity: 1;
            transform: translateX(0);
        }

        .isbn-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Editable cells */
        .editable-title, .editable-language {
            transition: all 0.3s ease;
        }

        .editable-title.editing, .editable-language.editing {
            background: #fff9e6;
            border: 2px solid #2e8b57;
            border-radius: 4px;
            padding: 8px;
            outline: none;
        }

        .editable-title.editing:focus, .editable-language.editing:focus {
            background: #fffef0;
            box-shadow: 0 0 5px rgba(46, 139, 87, 0.3);
        }

        .edit-btn:hover {
            transform: scale(1.2);
            transition: transform 0.2s;
        }

        /* Validation error styles */
        .validation-error {
            display: inline-block;
            margin-left: 5px;
            font-size: 16px;
            cursor: help;
            animation: pulse 2s infinite;
        }

        .invalid-field {
            background: #ffe6e6 !important;
            border-left: 3px solid #dc3545 !important;
            position: relative;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Slide Button Container */
        .slide-button-cell {
            padding: 8px !important;
        }

        /* Initial state - glossy light grey */
        .slide-container {
            position: relative;
            width: 320px;
            height: 60px;
            background: linear-gradient(180deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 30px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.1),
                        0 2px 10px rgba(0,0,0,0.15),
                        0 0 15px rgba(255,255,255,0.5);
            touch-action: none;
            user-select: none;
            border: 1px solid #d0d0d0;
            transition: all 0.4s ease;
        }

        /* Active state - green arrow indicator only */
        .slide-container.active .slide-button {
            background: linear-gradient(180deg, #90ee90 0%, #7bcf7b 100%);
            box-shadow: 0 4px 15px rgba(46, 139, 87, 0.5),
                        inset 0 2px 6px rgba(255,255,255,0.6),
                        inset 0 -2px 6px rgba(46, 139, 87, 0.2);
            border: 2px solid #6bc46b;
            color: #2d5a2d;
        }

        .slide-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: linear-gradient(135deg, #2e8b57 0%, #3cb371 100%);
            border-radius: 25px;
            transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .slide-button {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, #ffffff 0%, #f5f5f5 100%);
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2),
                        inset 0 2px 6px rgba(255,255,255,1),
                        inset 0 -2px 4px rgba(0,0,0,0.08);
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            z-index: 2;
            border: 2px solid #e8e8e8;
            color: #888;
        }

        /* Active state - green arrow (lit green button) */
        .slide-container.active .slide-button {
            background: linear-gradient(180deg, #90ee90 0%, #7bcf7b 100%);
            box-shadow: 0 4px 15px rgba(46, 139, 87, 0.5),
                        inset 0 2px 6px rgba(255,255,255,0.6),
                        inset 0 -2px 6px rgba(46, 139, 87, 0.2);
            border: 2px solid #6bc46b;
            color: #2d5a2d;
        }

        .slide-button:active {
            cursor: grabbing;
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .slide-text {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            pointer-events: none;
            z-index: 1;
            text-shadow: 0 1px 0 rgba(255,255,255,0.5);
            transition: all 0.3s ease;
        }

        /* Processing state */
        .slide-container.processing {
            background: linear-gradient(90deg, #4a90e2 0%, #5ba3f5 50%, #4a90e2 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.2),
                        0 2px 15px rgba(74, 144, 226, 0.5);
            border: 1px solid #3a7bc8;
        }

        .slide-container.processing .slide-button {
            left: calc(100% - 55px);
            background: linear-gradient(180deg, #ffffff 0%, #e3f2fd 100%);
            animation: pulse 1s infinite;
            cursor: wait;
        }

        .slide-container.processing .slide-text {
            color: white;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* Success state */
        .slide-container.unlocked {
            background: linear-gradient(135deg, #2e8b57 0%, #3cb371 100%);
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.15),
                        0 2px 20px rgba(46, 139, 87, 0.6),
                        0 0 30px rgba(60, 179, 113, 0.5);
            border: 1px solid #2e8b57;
            animation: successPulse 0.5s ease;
        }

        .slide-container.unlocked .slide-button {
            left: calc(100% - 55px);
            background: linear-gradient(180deg, #5cb85c 0%, #4caf50 100%);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.6),
                        inset 0 2px 6px rgba(255,255,255,0.4),
                        inset 0 -2px 6px rgba(0,0,0,0.2);
            border: 2px solid #66bb6a;
        }

        .slide-container.unlocked .slide-background {
            width: 100%;
        }

        .slide-container.unlocked .slide-text {
            color: white;
            font-weight: 700;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* Animations */
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes successPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @keyframes flashIn {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .empty-grid-message {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        /* Multi-select checkbox styles */
        .multi-select-container {
            border: 2px solid #2e8b57;
            border-radius: 8px;
            padding: 12px;
            background-color: #f8f9fa;
            margin-top: 5px;
        }

        .multi-select-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .multi-select-checkbox {
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            background-color: white;
            transition: all 0.3s;
            user-select: none;
            font-size: 13px;
        }

        .multi-select-checkbox:hover {
            border-color: #2e8b57;
            background-color: #f0f9f4;
        }

        .multi-select-checkbox input[type="checkbox"] {
            margin-right: 5px;
            cursor: pointer;
            width: 14px;
            height: 14px;
            accent-color: #2e8b57;
        }

        .multi-select-checkbox input[type="checkbox"]:checked + .checkbox-label {
            font-weight: 600;
            color: #2e8b57;
        }

        .multi-select-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 25px;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background-color: #2e8b57;
            color: white;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
        }

        .selected-tag .remove-tag {
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            line-height: 1;
            padding: 0 3px;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .selected-tag .remove-tag:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 24px;
            }

            .btn {
                padding: 12px 30px;
                font-size: 14px;
            }

            .isbn-table {
                font-size: 12px;
            }

            .isbn-table th,
            .isbn-table td {
                padding: 10px 8px;
            }

            #mainSlideButton {
                width: 280px;
                height: 50px;
            }

            #mainSlideButton .slide-button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }

            #mainSlideButton .slide-text {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì∑ Book Barcode Scanner</h1>
        <p class="subtitle">Scan ISBN barcodes to automatically retrieve book information</p>

        <!-- Info Box -->
        <div class="info-box">
            <strong>üìñ How to use:</strong> Click "Start Scanner" below to activate your camera. Point it at a book's ISBN barcode. Once scanned, book details will be fetched automatically from Google Books.
        </div>

        <!-- Iframe Warning -->
        <div id="iframeWarning" class="warning-box">
            <h2>‚ö†Ô∏è Camera Access Blocked</h2>
            <p>
                This page is embedded and camera access is blocked.<br>
                <strong>Click the button below to use the scanner:</strong>
            </p>
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="openInNewTab()" class="btn btn-warning">
                    üì∑ Open Scanner (Click Here!)
                </button>
            </div>
            <p style="font-size: 14px; opacity: 0.9;">
                This will open the scanner in a new tab where your camera will work.
            </p>
        </div>

        <!-- Camera View -->
        <div id="cameraViewContainer">
            <div id="reader"></div>
            <div id="scanStatus">Ready to scan</div>
        </div>

        <!-- Scanner Controls -->
        <div class="controls">
            <button id="startScanBtn" class="btn btn-primary" onclick="startScanner()">
                üì∑ Start Scanner
            </button>
            <button id="stopScanBtn" class="btn btn-secondary" onclick="stopScanner()" style="display: none;">
                ‚èπÔ∏è Stop Scanner
            </button>
        </div>

        <!-- Scanned Book Details -->
        <div id="scannedBookDetails">
            <h3>üìö Scanned Book Details</h3>
            <div class="detail-item">
                <strong>ISBN:</strong>
                <p id="scannedISBN"></p>
            </div>
            <div class="detail-item">
                <strong>Book Title:</strong>
                <p id="scannedBookTitle" style="font-weight: 600;"></p>
            </div>
            <div class="detail-item">
                <strong>Author(s):</strong>
                <p id="scannedAuthor"></p>
            </div>
            <div class="detail-item">
                <strong>Publisher:</strong>
                <p id="scannedPublisher"></p>
            </div>
            <div class="detail-item">
                <strong>Published Date:</strong>
                <p id="scannedPublishedDate"></p>
            </div>
            <div class="detail-item">
                <strong>Categories:</strong>
                <p id="scannedCategories"></p>
            </div>
            <div class="detail-item">
                <strong>Language:</strong>
                <p id="scannedLanguage"></p>
            </div>
            <div class="detail-item">
                <strong>Description:</strong>
                <p id="scannedDescription" style="font-size: 14px; line-height: 1.6; color: #666;"></p>
            </div>

            <div style="margin-top: 25px; text-align: center;">
                <button id="saveToISBNListBtn" class="btn btn-primary" onclick="saveToISBNList()" style="display: none;">
                    üíæ Save to ISBN List
                </button>
                <button class="btn btn-secondary" onclick="clearScannedBook()">
                    üîÑ Scan Another
                </button>
            </div>
        </div>

        <!-- ISBN Scanned Books Section -->
        <div id="isbnListSection">
            <h3>
                <span>üìö ISBN Scanned Books</span>
                <button class="refresh-grid-btn" onclick="loadISBNList()">üîÑ Refresh</button>
            </h3>

            <!-- Form for Book Registry Details -->
            <div id="registryForm" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #2e8b57;">
                <h4 style="color: #2e8b57; margin-bottom: 15px;">üìù Book Registry Information</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #5d4e37;">
                            Contact Person <span style="color: red;">*</span>
                        </label>
                        <input type="text" id="contactPerson" placeholder="Enter contact person name"
                            style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #5d4e37;">
                            Contact Number <span style="color: red;">*</span>
                        </label>
                        <input type="tel" id="contactNumber" placeholder="Enter contact number"
                            style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #5d4e37;">
                            Unit No <span style="color: red;">*</span>
                        </label>
                        <input type="text" id="unitNo" placeholder="Enter unit number"
                            style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666; font-style: italic;">
                    Fill in these details before sliding to save to Book Registry
                </p>
            </div>

            <!-- Table View -->
            <div id="isbnTableContainer" style="overflow-x: auto;">
                <div class="empty-grid-message">Loading ISBN List...</div>
            </div>

            <!-- iPhone-style Slide to Save Button -->
            <div id="slideToSaveSection" style="margin-top: 30px; text-align: center; display: none;">
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    <strong id="bookCount">0</strong> book(s) ready to save. Slide to save all to Book Registry.
                </p>
                <div style="display: flex; justify-content: center;">
                    <div class="slide-container" id="mainSlideButton">
                        <div class="slide-background"></div>
                        <div class="slide-text">Slide to Save All ‚Üí</div>
                        <div class="slide-button">‚Üí</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Alert -->
    <div id="alertBox" class="alert"></div>

    <script>
        // Configuration
        const DEFAULT_API_URL = 'https://script.google.com/macros/s/AKfycbytd5eKdlkBLJ9nxS2jx1C5A4pFNdkISnJoPwt2VFu7jzUpMYOa_F6oeZh1o4GY-pOO_w/exec';
        let API_URL = localStorage.getItem('apiUrl') || DEFAULT_API_URL;

        let html5QrcodeScanner = null;
        let currentScannedBook = null;
        let isScannerActive = false;

        // Cache for Google Books API responses (speeds up duplicate scans)
        const bookCache = new Map();

        // Check if running in iframe
        function isInIframe() {
            try {
                return window.self !== window.top;
            } catch (e) {
                return true;
            }
        }

        // Open in new tab
        function openInNewTab() {
            const currentUrl = window.location.href;
            window.open(currentUrl, '_blank');
        }

        // Show alert
        function showAlert(message, type) {
            const alertEl = document.getElementById('alertBox');
            alertEl.textContent = message;
            alertEl.className = 'alert alert-' + type;
            alertEl.style.display = 'block';

            setTimeout(() => {
                alertEl.style.display = 'none';
            }, 5000);
        }

        // Check iframe permissions on load
        async function checkIframePermissions() {
            console.log('=== IFRAME PERMISSION CHECK ===');

            if (!isInIframe()) {
                console.log('‚úÖ Not in iframe - camera should work normally');
                document.getElementById('iframeWarning').style.display = 'none';
                return;
            }

            console.log('‚ö†Ô∏è Running in iframe - checking camera...');
            document.getElementById('iframeWarning').style.display = 'block';

            try {
                const testStream = await navigator.mediaDevices.getUserMedia({ video: true });
                testStream.getTracks().forEach(track => track.stop());
                console.log('‚úÖ Camera IS accessible in iframe!');
                document.getElementById('iframeWarning').style.display = 'none';
            } catch (error) {
                console.log('‚ùå Camera NOT accessible in iframe');
                document.getElementById('iframeWarning').style.display = 'block';
            }
        }

        // Check camera permissions
        async function checkCameraPermissions() {
            console.log('=== CAMERA PERMISSION CHECK ===');

            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                throw new Error('Camera access requires HTTPS.');
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('Your browser does not support camera access.');
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                stream.getTracks().forEach(track => track.stop());
                return true;
            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    throw new Error('Camera permission denied. Please click "Allow" when asked.');
                }
                throw error;
            }
        }

        // Start Scanner
        async function startScanner() {
            try {
                document.getElementById('cameraViewContainer').style.display = 'block';
                document.getElementById('scanStatus').textContent = 'Checking camera permissions...';

                await checkCameraPermissions();
                document.getElementById('iframeWarning').style.display = 'none';

                document.getElementById('scanStatus').textContent = 'Initializing camera...';

                if (!html5QrcodeScanner) {
                    html5QrcodeScanner = new Html5Qrcode("reader");
                }

                const config = {
                    fps: 10,
                    qrbox: { width: 300, height: 150 },
                    formatsToSupport: [
                        Html5QrcodeSupportedFormats.EAN_13,
                        Html5QrcodeSupportedFormats.EAN_8,
                        Html5QrcodeSupportedFormats.UPC_A,
                        Html5QrcodeSupportedFormats.UPC_E
                    ]
                };

                const onScanSuccess = async (decodedText) => {
                    console.log('Scanned barcode:', decodedText);
                    document.getElementById('scanStatus').textContent = `ISBN detected: ${decodedText}. Fetching book details...`;
                    document.getElementById('scanStatus').style.background = '#d4edda';
                    document.getElementById('scanStatus').style.color = '#155724';
                    document.getElementById('scanStatus').style.borderLeft = '4px solid #28a745';

                    await stopScanner();
                    await fetchBookDetails(decodedText);
                };

                const onScanFailure = (error) => {
                    // Ignore - fires when no barcode detected
                };

                try {
                    await html5QrcodeScanner.start(
                        { facingMode: "environment" },
                        config,
                        onScanSuccess,
                        onScanFailure
                    );
                } catch (error) {
                    await html5QrcodeScanner.start(
                        { facingMode: "user" },
                        config,
                        onScanSuccess,
                        onScanFailure
                    );
                }

                isScannerActive = true;
                document.getElementById('scanStatus').textContent = 'Point camera at ISBN barcode...';
                document.getElementById('scanStatus').style.background = '#e7f3ff';
                document.getElementById('scanStatus').style.color = '#2196F3';
                document.getElementById('scanStatus').style.borderLeft = '4px solid #2196F3';
                document.getElementById('startScanBtn').style.display = 'none';
                document.getElementById('stopScanBtn').style.display = 'inline-block';

                showAlert('Scanner activated!', 'success');
            } catch (error) {
                console.error('‚ùå Error starting scanner:', error);

                if (isInIframe() && (error.name === 'NotAllowedError' || error.message.includes('denied'))) {
                    document.getElementById('iframeWarning').style.display = 'block';
                }

                showAlert(error.message || 'Failed to start camera', 'error');
                document.getElementById('cameraViewContainer').style.display = 'none';
                isScannerActive = false;
            }
        }

        // Stop Scanner
        async function stopScanner() {
            try {
                if (html5QrcodeScanner && isScannerActive) {
                    await html5QrcodeScanner.stop();
                    isScannerActive = false;
                }

                document.getElementById('cameraViewContainer').style.display = 'none';
                document.getElementById('startScanBtn').style.display = 'inline-block';
                document.getElementById('stopScanBtn').style.display = 'none';
                document.getElementById('scanStatus').textContent = 'Ready to scan';
                document.getElementById('scanStatus').style.background = '#e7f3ff';
                document.getElementById('scanStatus').style.color = '#2196F3';
            } catch (error) {
                console.error('Error stopping scanner:', error);
            }
        }

        // Language mapping function - maps locale codes to full language names
        function mapLanguage(localeCode) {
            // Return 'English' as default if no input
            if (!localeCode || localeCode.trim() === '' || localeCode === 'N/A') {
                return 'English';
            }

            // Normalize the input to lowercase for consistent matching
            const normalizedCode = localeCode.toLowerCase().trim();

            console.log('üåç Mapping language for locale:', localeCode);

            // Language locale to full name mapping
            const languageMap = {
                // Indian Languages
                'en': 'English',
                'en-us': 'English',
                'en-gb': 'English',
                'hi': 'Hindi',
                'bn': 'Bengali',
                'ta': 'Tamil',
                'te': 'Telugu',
                'mr': 'Marathi',
                'ur': 'Urdu',
                'gu': 'Gujarati',
                'kn': 'Kannada',
                'ml': 'Malayalam',
                // International Languages
                'es': 'Spanish',
                'fr': 'French',
                'ar': 'Arabic',
                'zh': 'Chinese',
                'zh-cn': 'Chinese',
                'zh-tw': 'Chinese',
                'ja': 'Japanese',
                'de': 'German',
                'ru': 'Russian',
                // Full names (in case API returns full names)
                'english': 'English',
                'hindi': 'Hindi',
                'bengali': 'Bengali',
                'tamil': 'Tamil',
                'telugu': 'Telugu',
                'marathi': 'Marathi',
                'urdu': 'Urdu',
                'gujarati': 'Gujarati',
                'kannada': 'Kannada',
                'malayalam': 'Malayalam',
                'spanish': 'Spanish',
                'french': 'French',
                'arabic': 'Arabic',
                'chinese': 'Chinese',
                'japanese': 'Japanese',
                'german': 'German',
                'russian': 'Russian'
            };

            // Try exact match first
            if (languageMap[normalizedCode]) {
                console.log('‚úÖ Language mapped:', localeCode, '‚Üí', languageMap[normalizedCode]);
                return languageMap[normalizedCode];
            }

            // If no match found, return English as default
            console.log('‚ö†Ô∏è No language match found for:', localeCode, '- defaulting to English');
            return 'English';
        }

        // Category mapping function - maps Genre to Age Range Category
        // Based on CategoryBestMap.txt logic
        function mapCategory(genreValue) {
            // Return 'N/A' if no genre provided
            if (!genreValue || genreValue === 'Unknown' || genreValue === 'N/A') {
                return 'N/A';
            }

            console.log('üë∂ Mapping category for genre:', genreValue);

            // Category mapping rules from CategoryBestMap.txt
            // Priority order matters - check from most specific to least specific

            // Rule 1: Short-Story ‚Üí 0 to 3 yrs
            if (genreValue.includes('Short-Story')) {
                console.log('‚úÖ Category mapped:', genreValue, '‚Üí 0 to 3 yrs');
                return '0 to 3 yrs';
            }

            // Rule 2: Children's Specific or FairyTale ‚Üí 3 to 7 yrs
            if (genreValue.includes("Children's Specific") || genreValue.includes('FairyTale')) {
                console.log('‚úÖ Category mapped:', genreValue, '‚Üí 3 to 7 yrs');
                return '3 to 7 yrs';
            }

            // Rule 3: Mystery or Humour or Magical ‚Üí 7 to 12 yrs
            // Note: Children's Specific already handled above, so this catches other cases
            if (genreValue.includes('Mystery') || genreValue.includes('Humour') || genreValue.includes('Magical')) {
                console.log('‚úÖ Category mapped:', genreValue, '‚Üí 7 to 12 yrs');
                return '7 to 12 yrs';
            }

            // Rule 4: Teen-Aged or Fiction or Sci-fi or Adventure or Thriller or Fantasy ‚Üí 12 to 18 yrs
            if (genreValue.includes('Teen-Aged') || genreValue.includes('Fiction') ||
                genreValue.includes('Sci-fi') || genreValue.includes('Adventure') ||
                genreValue.includes('Thriller') || genreValue.includes('Fantasy')) {
                console.log('‚úÖ Category mapped:', genreValue, '‚Üí 12 to 18 yrs');
                return '12 to 18 yrs';
            }

            // Rule 5: Adult content ‚Üí 18 +
            if (genreValue.includes('Historical Fiction') || genreValue.includes('Philosophical') ||
                genreValue.includes('Motivational') || genreValue.includes('Memoir') ||
                genreValue.includes('Biography') || genreValue.includes('Poetry') ||
                genreValue.includes('Romance') || genreValue.includes('Classics') ||
                genreValue.includes('Dystopian') || genreValue.includes('Contemporary') ||
                genreValue.includes('Graphic') || genreValue.includes('Literary')) {
                console.log('‚úÖ Category mapped:', genreValue, '‚Üí 18 +');
                return '18 +';
            }

            // Default fallback for unmapped genres
            console.log('‚ö†Ô∏è No category match found for genre:', genreValue, '- defaulting to N/A');
            return 'N/A';
        }

        // Genre mapping function - maps input categories to standardized genres
        function mapGenre(inputCategories) {
            // Return 'Unknown' if no input
            if (!inputCategories || inputCategories.trim() === '' || inputCategories === 'N/A') {
                return 'Unknown';
            }

            // Normalize the input to lowercase for consistent matching
            const normalizedInput = inputCategories.toLowerCase().trim();

            console.log('üé≠ Mapping genre for categories:', inputCategories);

            // Genre mapping table based on GenreBestMatch.txt
            const genreMap = {
                'fiction': 'Fiction',
                'novel': 'Fiction',
                'fantasy': 'Fantasy',
                'horror': 'Horror',
                'romance': 'Romance',
                'love': 'Romance',
                'graphic': 'Graphic',
                'literary': 'Literary',
                'literature': 'Literary',
                'adventure': 'Adventure',
                'short': 'Short-Story',
                'short story': 'Short-Story',
                'dystopian': 'Dystopian',
                'contemporary': 'Contemporary',
                'traditional': 'Contemporary',
                'fairy': 'FairyTale',
                'fairy tale': 'FairyTale',
                'poem': 'Poetry',
                'poetry': 'Poetry',
                'classic': 'Classics',
                'classical': 'Classics',
                'humor': 'Humour',
                'humour': 'Humour',
                'joke': 'Humour',
                'fun': 'Humour',
                'comic': 'Humour',
                'comedy': 'Humour',
                'magic': 'Magical',
                'philosophy': 'Philosophical',
                'philosophical': 'Philosophical',
                'motivational': 'Motivational',
                'scifi': 'Sci-fi',
                'sci-fi': 'Sci-fi',
                'science fiction': 'Sci-fi',
                'historical': 'Historical Fiction',
                'history': 'Historical Fiction',
                'childrens': 'Children\'s Specific',
                'children': 'Children\'s Specific',
                'kids': 'Children\'s Specific',
                'juvenile': 'Children\'s Specific',
                'teenaged': 'Teen-Aged',
                'teen': 'Teen-Aged',
                'ya': 'Teen-Aged',
                'young adult': 'Teen-Aged',
                'mystery': 'Mystery',
                'thriller': 'Thriller',
                'suspense': 'Thriller',
                'nonfiction': 'Non-Fiction',
                'non-fiction': 'Non-Fiction',
                'biography': 'Biography',
                'biographical': 'Biography',
                'memoir': 'Memoir',
                'autofiction': 'Memoir',
                'autobiography': 'Memoir'
            };

            // Try exact match first
            if (genreMap[normalizedInput]) {
                console.log('‚úÖ Exact match found:', genreMap[normalizedInput]);
                return genreMap[normalizedInput];
            }

            // Try to find matches using regex (search for keywords within the input)
            let bestMatch = null;
            let longestMatch = 0;

            for (const [keyword, genre] of Object.entries(genreMap)) {
                // Create regex to match whole word boundaries
                const regex = new RegExp('\\b' + keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');

                if (regex.test(normalizedInput)) {
                    // Prioritize longer matches (more specific)
                    if (keyword.length > longestMatch) {
                        longestMatch = keyword.length;
                        bestMatch = genre;
                    }
                }
            }

            if (bestMatch) {
                console.log('‚úÖ Regex match found:', bestMatch);
                return bestMatch;
            }

            // If no match found, return Unknown
            console.log('‚ö†Ô∏è No genre match found, returning Unknown');
            return 'Unknown';
        }

        // Validate book data has required fields
        function isValidBookData(book) {
            // Check if title exists and is not empty or 'N/A'
            const hasValidTitle = book.title &&
                                  book.title.trim() !== '' &&
                                  book.title !== 'N/A' &&
                                  book.title !== 'Not Found';

            // Check if authors exist and are not empty or 'N/A'
            const hasValidAuthor = book.authors &&
                                   book.authors.trim() !== '' &&
                                   book.authors !== 'N/A';

            return hasValidTitle && hasValidAuthor;
        }

        // Fetch Book Details from Google Books API (with caching)
        async function fetchBookDetails(isbn) {
            console.log('‚ö° Fetching book details for ISBN:', isbn);
            const startTime = performance.now();

            // Check cache first for instant response
            if (bookCache.has(isbn)) {
                console.log('‚ú® Using cached data for ISBN:', isbn);
                currentScannedBook = bookCache.get(isbn);

                // Validate cached data
                if (!isValidBookData(currentScannedBook)) {
                    console.error('‚ùå Cached book has invalid data, not saving');
                    showAlert('‚ö†Ô∏è ISBN could not load valid book details from the book scanner API. Missing title or author information.', 'error');
                    return;
                }

                displayScannedBookQuick(currentScannedBook);
                await saveToISBNListQuick();
                return;
            }

            const apiUrl = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;

            try {
                const response = await fetch(apiUrl);
                const data = await response.json();

                const fetchTime = performance.now() - startTime;
                console.log(`‚è±Ô∏è API response time: ${fetchTime.toFixed(0)}ms`);

                if (data.items && data.items.length > 0) {
                    const bookInfo = data.items[0].volumeInfo;

                    // Get categories from API
                    const rawCategories = bookInfo.categories ? bookInfo.categories.join(', ') : 'N/A';

                    // Get language locale from API
                    const rawLanguage = bookInfo.language || 'en';

                    // Map genre using the categories
                    const mappedGenre = mapGenre(rawCategories);

                    // Map category (age range) based on mapped genre
                    const mappedCategory = mapCategory(mappedGenre);

                    // Map language locale to full language name
                    const mappedLanguage = mapLanguage(rawLanguage);

                    currentScannedBook = {
                        isbn: isbn,
                        title: bookInfo.title || '',
                        authors: bookInfo.authors ? bookInfo.authors.join(', ') : '',
                        publisher: bookInfo.publisher || 'N/A',
                        publishedDate: bookInfo.publishedDate || 'N/A',
                        categories: rawCategories,
                        genre: mappedGenre,  // Add mapped genre field
                        category: mappedCategory,  // Add mapped category (age range)
                        description: bookInfo.description || 'No description available',
                        language: mappedLanguage  // Use mapped language instead of raw
                    };

                    console.log('üìö Book genre mapped:', rawCategories, '‚Üí', mappedGenre);
                    console.log('üë∂ Book category mapped:', mappedGenre, '‚Üí', mappedCategory);
                    console.log('üåç Book language mapped:', rawLanguage, '‚Üí', mappedLanguage);

                    // Validate book data before proceeding
                    if (!isValidBookData(currentScannedBook)) {
                        console.error('‚ùå Book data is invalid - missing title or author');
                        showAlert('‚ö†Ô∏è ISBN could not load valid book details from the book scanner API. Missing title or author information.', 'error');
                        currentScannedBook = null;
                        return;
                    }

                    // Cache the result for future scans (only if valid)
                    bookCache.set(isbn, currentScannedBook);

                    displayScannedBookQuick(currentScannedBook);
                    await saveToISBNListQuick();
                } else {
                    // No book found in API
                    console.error('‚ùå No book details found for ISBN:', isbn);
                    showAlert('‚ö†Ô∏è ISBN could not load valid book details from the book scanner API. No book found for this ISBN.', 'error');
                    currentScannedBook = null;
                }
            } catch (error) {
                console.error('Error fetching book details:', error);
                showAlert('‚ö†Ô∏è Error connecting to book scanner API. Please try again.', 'error');
                currentScannedBook = null;
            }

            const totalTime = performance.now() - startTime;
            console.log(`‚úÖ Total processing time: ${totalTime.toFixed(0)}ms`);
        }

        // Display Scanned Book (Quick - flashes for 1.5 seconds then auto-hides)
        function displayScannedBookQuick(book) {
            document.getElementById('scannedISBN').textContent = book.isbn;
            document.getElementById('scannedBookTitle').textContent = book.title;
            document.getElementById('scannedAuthor').textContent = book.authors;
            document.getElementById('scannedPublisher').textContent = book.publisher;
            document.getElementById('scannedPublishedDate').textContent = book.publishedDate;
            document.getElementById('scannedCategories').textContent = book.categories;
            document.getElementById('scannedLanguage').textContent = book.language;
            document.getElementById('scannedDescription').textContent = book.description;

            const detailsEl = document.getElementById('scannedBookDetails');
            detailsEl.style.display = 'block';

            // Add flash animation
            detailsEl.style.animation = 'flashIn 0.3s ease-in-out';

            // Auto-hide after 1.5 seconds
            setTimeout(() => {
                detailsEl.style.animation = 'fadeOut 0.3s ease-in-out';
                setTimeout(() => {
                    detailsEl.style.display = 'none';
                    detailsEl.style.animation = '';
                }, 300);
            }, 1500);
        }

        // Display Scanned Book (original - for manual viewing)
        function displayScannedBook(book) {
            document.getElementById('scannedISBN').textContent = book.isbn;
            document.getElementById('scannedBookTitle').textContent = book.title;
            document.getElementById('scannedAuthor').textContent = book.authors;
            document.getElementById('scannedPublisher').textContent = book.publisher;
            document.getElementById('scannedPublishedDate').textContent = book.publishedDate;
            document.getElementById('scannedCategories').textContent = book.categories;
            document.getElementById('scannedLanguage').textContent = book.language;
            document.getElementById('scannedDescription').textContent = book.description;
            document.getElementById('scannedBookDetails').style.display = 'block';
        }

        // Clear Scanned Book
        function clearScannedBook() {
            currentScannedBook = null;
            document.getElementById('scannedBookDetails').style.display = 'none';
        }

        // Track pending saves for batch refresh
        let pendingSaves = 0;
        let refreshTimer = null;

        // Save to ISBN_List Sheet (Quick - with optimistic UI update)
        async function saveToISBNListQuick() {
            if (!currentScannedBook) {
                console.log('No book data to save');
                return;
            }

            const dataToSend = {
                action: 'addISBN',
                isbn: currentScannedBook.isbn,
                bookTitle: currentScannedBook.title,
                authors: currentScannedBook.authors,
                publisher: currentScannedBook.publisher,
                publishedDate: currentScannedBook.publishedDate,
                categories: currentScannedBook.categories,
                language: currentScannedBook.language,
                genre: currentScannedBook.genre || 'Unknown',
                category: currentScannedBook.category || 'N/A'  // Use mapped category
            };

            console.log('‚ö° Quick saving to ISBN_List:', dataToSend);

            // Optimistic UI update - add to table immediately
            addBookToTableOptimistic(currentScannedBook);

            // Track pending save
            pendingSaves++;

            try {
                // Save in background without blocking
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSend),
                    redirect: 'follow'
                });

                const result = await response.json();
                console.log('Save result:', result);

                if (result.success) {
                    console.log('‚úÖ Book saved successfully to Google Sheets');
                    // Update the optimistic row to confirmed state
                    confirmOptimisticBook(currentScannedBook.isbn);
                } else {
                    if (result.message.includes('already exists')) {
                        console.log('Book already exists, keeping optimistic update');
                        confirmOptimisticBook(currentScannedBook.isbn);
                    } else {
                        console.error('Save failed:', result.message);
                        // Remove the optimistic row
                        removeOptimisticBook(currentScannedBook.isbn);
                        showAlert('Failed: ' + result.message, 'error');
                    }
                }
            } catch (error) {
                console.error('Error saving:', error);
                // Remove the optimistic row
                removeOptimisticBook(currentScannedBook.isbn);
                showAlert('Error saving book', 'error');
            } finally {
                // Decrement pending saves
                pendingSaves--;

                // Schedule a refresh when all saves are complete
                if (pendingSaves === 0) {
                    // Clear any existing timer
                    if (refreshTimer) {
                        clearTimeout(refreshTimer);
                    }

                    // Refresh table after a short delay to sync with Google Sheets
                    refreshTimer = setTimeout(() => {
                        console.log('üîÑ All saves complete, refreshing table from Google Sheets');
                        loadISBNList();
                    }, 1000); // Wait 1 second to ensure Google Sheets is updated
                }
            }
        }

        // Save to ISBN_List Sheet (original - for manual saves)
        async function saveToISBNList() {
            if (!currentScannedBook) {
                console.log('No book data to save');
                return;
            }

            const saveBtn = document.getElementById('saveToISBNListBtn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }

            const dataToSend = {
                action: 'addISBN',
                isbn: currentScannedBook.isbn,
                bookTitle: currentScannedBook.title,
                authors: currentScannedBook.authors,
                publisher: currentScannedBook.publisher,
                publishedDate: currentScannedBook.publishedDate,
                categories: currentScannedBook.categories,
                language: currentScannedBook.language,
                genre: currentScannedBook.genre || 'Unknown',
                category: currentScannedBook.category || 'N/A'  // Use mapped category
            };

            console.log('Saving to ISBN_List:', dataToSend);

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSend),
                    redirect: 'follow'
                });

                const result = await response.json();
                console.log('Save result:', result);

                if (result.success) {
                    showAlert('‚úÖ Book saved to ISBN_List successfully!', 'success');
                    // Auto-refresh the ISBN List grid view
                    await loadISBNList();
                    clearScannedBook();
                } else {
                    // Show alert only if it's not a duplicate
                    if (!result.message.includes('already exists')) {
                        showAlert('Failed: ' + result.message, 'error');
                    } else {
                        console.log('Book already in ISBN_List:', result.message);
                        // Still refresh to show it's there
                        await loadISBNList();
                    }
                }
            } catch (error) {
                console.error('Error saving:', error);
                showAlert('Error saving book', 'error');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save to ISBN List';
                }
            }
        }

        // Load ISBN_List from Google Sheets
        async function loadISBNList() {
            const tableContainer = document.getElementById('isbnTableContainer');

            // Don't clear the table during refresh - keep optimistic updates visible
            const existingTable = tableContainer.querySelector('.isbn-table');
            if (!existingTable) {
                tableContainer.innerHTML = '<div class="empty-grid-message">Loading...</div>';
            } else {
                console.log('üì• Refreshing table data (keeping existing rows visible)...');
            }

            const dataToSend = {
                action: 'getISBNList'
            };

            console.log('üì• Loading ISBN_List from Google Sheets...');
            console.log('API URL:', API_URL);
            console.log('Request:', JSON.stringify(dataToSend));

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSend),
                    redirect: 'follow'
                });

                console.log('Response status:', response.status, response.statusText);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const result = await response.json();
                console.log('‚úì Response received:', result);
                console.log('Success:', result.success);
                console.log('Data length:', result.data ? result.data.length : 'null');
                console.log('Full data:', result.data);

                if (result.success) {
                    if (result.data && Array.isArray(result.data) && result.data.length > 0) {
                        console.log('‚úì Displaying', result.data.length, 'books in table');
                        displayISBNTable(result.data);
                    } else {
                        console.log('‚ÑπÔ∏è No books in ISBN_List');
                        tableContainer.innerHTML = '<div class="empty-grid-message">No books saved yet. Scan a book to get started!</div>';
                        document.getElementById('slideToSaveSection').style.display = 'none';
                    }
                } else {
                    console.error('‚ùå Server returned success=false:', result.message);
                    tableContainer.innerHTML = `<div class="empty-grid-message">Server Error: ${result.message || 'Unknown error'}</div>`;
                }
            } catch (error) {
                console.error('‚ùå Error loading ISBN List:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                tableContainer.innerHTML = `
                    <div class="empty-grid-message">
                        Error loading ISBN List<br>
                        <small style="color: #999; margin-top: 10px; display: block;">${error.message}</small><br>
                        <button onclick="loadISBNList()" style="margin-top: 10px; padding: 8px 16px; background: #2e8b57; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            üîÑ Retry
                        </button>
                    </div>
                `;
            }
        }

        // Display ISBN_List in table view
        function displayISBNTable(books) {
            console.log('üìä displayISBNTable called with:', books);
            console.log('Books array length:', books ? books.length : 'null');

            const tableContainer = document.getElementById('isbnTableContainer');

            if (!books || books.length === 0) {
                console.log('‚ö†Ô∏è No books to display');
                tableContainer.innerHTML = '<div class="empty-grid-message">No books saved yet. Scan a book to get started!</div>';
                return;
            }

            // Sort books by most recent (reverse order)
            const sortedBooks = [...books].reverse();
            console.log('üìã Sorted books:', sortedBooks);

            let tableHTML = `
                <table class="isbn-table">
                    <thead>
                        <tr>
                            <th>ISBN</th>
                            <th>Book Title</th>
                            <th>Author</th>
                            <th>Genre</th>
                            <th>Category</th>
                            <th>Language</th>
                            <th style="width: 60px; text-align: center;">Edit</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            sortedBooks.forEach((book, index) => {
                console.log(`Book ${index + 1}:`, book);

                // Use mapped genre from database, fallback to first category if not available
                const mappedGenre = book.genre || 'Unknown';

                // Get category from book object (Age Range)
                const category = book.category || 'N/A';

                console.log(`  - Mapped Genre: ${mappedGenre}, Category: ${category}`);

                // Validate dropdown values
                // Genre and Category: strict validation (no placeholders allowed)
                const isGenreValid = isValidDropdownValue(mappedGenre, GENRE_OPTIONS, false);
                const isCategoryValid = isValidDropdownValue(category, CATEGORY_OPTIONS, false);
                // Language: allow placeholders
                const isLanguageValid = isValidDropdownValue(book.language, LANGUAGE_OPTIONS, true);

                // Add validation indicators
                const genreIndicator = getValidationIndicator(isGenreValid);
                const categoryIndicator = getValidationIndicator(isCategoryValid);
                const languageIndicator = getValidationIndicator(isLanguageValid);

                // Add invalid-field class if validation fails
                const genreClass = isGenreValid ? '' : 'invalid-field';
                const categoryClass = isCategoryValid ? '' : 'invalid-field';
                const languageClass = isLanguageValid ? '' : 'invalid-field';

                tableHTML += `
                    <tr data-isbn="${book.isbn}"
                        data-title="${book.bookTitle || 'Unknown Title'}"
                        data-author="${book.authors || 'N/A'}"
                        data-genre="${mappedGenre}"
                        data-category="${category}"
                        data-language="${book.language || 'N/A'}"
                        id="row-${book.isbn}">
                        <td>${book.isbn || 'N/A'}</td>
                        <td class="editable-title"><strong>${book.bookTitle || 'Unknown Title'}</strong></td>
                        <td>${book.authors || 'N/A'}</td>
                        <td class="${genreClass}"><strong>${mappedGenre}</strong>${genreIndicator}</td>
                        <td class="${categoryClass}">${category}${categoryIndicator}</td>
                        <td class="editable-language ${languageClass}">${book.language || 'N/A'}${languageIndicator}</td>
                        <td style="text-align: center;">
                            <button class="edit-btn" onclick="toggleEditMode('${book.isbn}')"
                                style="background: none; border: none; cursor: pointer; font-size: 18px; color: #2e8b57; padding: 5px;">
                                ‚úèÔ∏è
                            </button>
                        </td>
                    </tr>
                `;
            });

            console.log('‚úì Table HTML generated, rows:', sortedBooks.length);

            tableHTML += `
                    </tbody>
                </table>
            `;

            tableContainer.innerHTML = tableHTML;
            console.log('‚úì Table inserted into DOM');

            // Update book count
            document.getElementById('bookCount').textContent = sortedBooks.length;
            console.log('‚úì Book count updated:', sortedBooks.length);

            // Show the slide button section
            document.getElementById('slideToSaveSection').style.display = 'block';
            console.log('‚úì Slide button section shown');

            // Initialize the main slide button
            initializeMainSlideButton();
            console.log('‚úì Slide button initialized');

            // Activate glossy green state when books are loaded
            const slideContainer = document.getElementById('mainSlideButton');
            if (slideContainer) {
                slideContainer.classList.add('active');
                console.log('‚úì Slide button activated (glossy green)');
            }
        }

        // Track if slider has been initialized to prevent duplicate event listeners
        let sliderInitialized = false;

        // Initialize main slide button functionality
        function initializeMainSlideButton() {
            const container = document.getElementById('mainSlideButton');
            if (!container) return;

            // Prevent re-initialization to avoid duplicate event listeners
            if (sliderInitialized) {
                console.log('‚ö†Ô∏è Slider already initialized, skipping to prevent duplicate listeners');
                return;
            }

            const slideButton = container.querySelector('.slide-button');
            const slideBackground = container.querySelector('.slide-background');
            let isDragging = false;
            let startX = 0;
            let currentX = 0;

            const handleStart = (e) => {
                isDragging = true;
                startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                slideButton.style.transition = 'none';
                slideBackground.style.transition = 'none';
            };

            const handleMove = (e) => {
                if (!isDragging) return;

                e.preventDefault();
                currentX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const deltaX = currentX - startX;
                const maxDistance = container.offsetWidth - slideButton.offsetWidth - 10;

                if (deltaX >= 0 && deltaX <= maxDistance) {
                    slideButton.style.left = `${5 + deltaX}px`;
                    const percentage = (deltaX / maxDistance) * 100;
                    slideBackground.style.width = `${percentage}%`;
                }
            };

            const handleEnd = async (e) => {
                if (!isDragging) return;
                isDragging = false;

                slideButton.style.transition = 'all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
                slideBackground.style.transition = 'width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';

                const deltaX = currentX - startX;
                const maxDistance = container.offsetWidth - slideButton.offsetWidth - 10;

                // If slid more than 80%, validate and trigger save
                if (deltaX > maxDistance * 0.8) {
                    // Validate: Check for errors or edit mode
                    const hasErrors = document.querySelector('.invalid-field') !== null;
                    const isEditing = document.querySelector('.editing') !== null;

                    if (hasErrors) {
                        showAlert('‚ö†Ô∏è Please fix all validation errors (red X) before saving!', 'error');
                        // Reset slider
                        slideButton.style.left = '5px';
                        slideBackground.style.width = '0%';
                        return;
                    }

                    if (isEditing) {
                        showAlert('‚ö†Ô∏è Please save or cancel all edits (pen icon) before saving!', 'error');
                        // Reset slider
                        slideButton.style.left = '5px';
                        slideBackground.style.width = '0%';
                        return;
                    }

                    // All validations passed, proceed with save
                    container.classList.add('unlocked');
                    slideButton.textContent = '‚úì';
                    slideBackground.style.width = '100%';

                    await saveToBookRegistryFromSlide(container);
                } else {
                    // Reset
                    slideButton.style.left = '5px';
                    slideBackground.style.width = '0%';
                }
            };

            // Mouse events
            slideButton.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            slideButton.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd);

            // Mark as initialized
            sliderInitialized = true;
            console.log('‚úì Slider event listeners attached (first time only)');
        }

        // Track if save operation is in progress to prevent duplicate submissions
        let isSaving = false;

        // Save ALL books to Book_Registry Sheet from main slide button (BULK SAVE)
        async function saveToBookRegistryFromSlide(slideContainer) {
            // Prevent duplicate submissions
            if (isSaving) {
                console.log('‚ö†Ô∏è Save already in progress, ignoring duplicate call');
                return;
            }

            isSaving = true;
            console.log('üîí Save operation started, blocking duplicate calls');

            // Validate form fields
            const contactPerson = document.getElementById('contactPerson').value.trim();
            const contactNumber = document.getElementById('contactNumber').value.trim();
            const unitNo = document.getElementById('unitNo').value.trim();

            if (!contactPerson || !contactNumber || !unitNo) {
                showAlert('‚ö†Ô∏è Please fill in Contact Person, Contact Number, and Unit No before saving!', 'error');

                // Reset slide button and unlock save
                isSaving = false;
                setTimeout(() => {
                    resetSlideButton(slideContainer);
                }, 500);

                return;
            }

            // Get all books from the table
            const rows = document.querySelectorAll('.isbn-table tbody tr');

            if (rows.length === 0) {
                showAlert('‚ö†Ô∏è No books to save!', 'error');
                isSaving = false;
                setTimeout(() => {
                    resetSlideButton(slideContainer);
                }, 500);
                return;
            }

            // Switch to processing state
            slideContainer.classList.remove('active', 'unlocked');
            slideContainer.classList.add('processing');
            const slideText = slideContainer.querySelector('.slide-text');
            const slideButton = slideContainer.querySelector('.slide-button');
            slideText.textContent = '‚è≥ Processing...';
            slideButton.textContent = '‚è≥';

            console.log('üîÑ Switched to processing state');

            const books = [];
            rows.forEach(row => {
                books.push({
                    isbn: row.dataset.isbn,
                    bookTitle: row.dataset.title,
                    author: row.dataset.author,
                    genre: row.dataset.genre,
                    category: row.dataset.category,
                    language: row.dataset.language
                });
            });

            const dataToSend = {
                action: 'bulkSaveToBookRegistry',
                books: books,
                contactPerson: contactPerson,
                contactNumber: contactNumber,
                unitNo: unitNo
            };

            console.log('Bulk saving to Book_Registry:', dataToSend);

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSend),
                    redirect: 'follow'
                });

                const result = await response.json();
                console.log('Bulk save result:', result);

                if (result.success) {
                    // Switch to success state
                    slideContainer.classList.remove('processing', 'active');
                    slideContainer.classList.add('unlocked');
                    slideText.textContent = '‚úÖ Saved Successfully!';
                    slideButton.textContent = '‚úì';

                    console.log('‚úÖ Switched to success state');

                    showAlert(`‚úÖ Successfully saved ${result.data.savedCount || books.length} book(s) to Book Registry!`, 'success');

                    // Clear the entire table with animation after brief delay
                    setTimeout(() => {
                        const tbody = document.querySelector('.isbn-table tbody');
                        if (tbody) {
                            // Animate all rows out
                            rows.forEach((row, index) => {
                                setTimeout(() => {
                                    row.style.opacity = '0';
                                    row.style.transform = 'translateX(100%)';
                                }, index * 50); // Stagger the animations
                            });

                            // After all animations, clear the view
                            setTimeout(() => {
                                // Reset slider to initial glossy grey state before hiding
                                resetSlideButton(slideContainer);

                                document.getElementById('slideToSaveSection').style.display = 'none';
                                loadISBNList(); // Reload to show empty message

                                // Clear the form fields
                                document.getElementById('contactPerson').value = '';
                                document.getElementById('contactNumber').value = '';
                                document.getElementById('unitNo').value = '';

                                // Unlock save for future operations
                                isSaving = false;
                                console.log('üîì Save operation completed, unlocked for next use');
                            }, rows.length * 50 + 300);
                        }
                    }, 1000); // Wait 1 second to show success state
                } else {
                    showAlert('Failed: ' + result.message, 'error');

                    // Reset slide button back to active state and unlock save
                    isSaving = false;
                    setTimeout(() => {
                        resetSlideButton(slideContainer);
                    }, 500);
                }
            } catch (error) {
                console.error('Error bulk saving to Book Registry:', error);
                showAlert('Error saving books to registry', 'error');

                // Reset slide button back to active state and unlock save
                isSaving = false;
                setTimeout(() => {
                    resetSlideButton(slideContainer);
                }, 500);
            }
        }

        // Reset slide button helper function
        function resetSlideButton(slideContainer) {
            slideContainer.classList.remove('unlocked', 'processing', 'active');
            const slideButton = slideContainer.querySelector('.slide-button');
            const slideBackground = slideContainer.querySelector('.slide-background');
            const slideText = slideContainer.querySelector('.slide-text');
            slideButton.textContent = '‚Üí';
            slideText.textContent = 'Slide to Save All ‚Üí';
            slideButton.style.left = '5px';
            slideBackground.style.width = '0%';
        }

        // Static dropdown values from BookScan.html
        const GENRE_OPTIONS = ["Historical Fiction", "Horror", "Fantasy", "Mystery", "Romance",
                               "Sci-fi", "Biography", "Graphic", "Memoir", "Thriller", "Literary",
                               "Adventure", "Short-Story", "Dystopian", "Contemporary", "FairyTale",
                               "Poetry", "Classics", "Humour", "Teen-Aged", "Philosophical",
                               "Children's Specific", "Magical", "Motivational"];

        const CATEGORY_OPTIONS = ["0 to 3 yrs", "3 to 7 yrs", "7 to 12 yrs", "12 to 18 yrs", "18 +"];

        const LANGUAGE_OPTIONS = ["English", "Hindi", "Bengali", "Tamil", "Telugu", "Marathi",
                                  "Urdu", "Gujarati", "Kannada", "Malayalam", "Spanish",
                                  "French", "Arabic", "Chinese", "Japanese", "German", "Russian"];

        // Validation function - checks if value exists in allowed options
        // Handles both single values and comma-separated values
        // allowPlaceholders: if true, accepts 'N/A' and 'Unknown' as valid (for Language)
        //                    if false, requires actual values from options (for Genre and Category)
        function isValidDropdownValue(value, options, allowPlaceholders = true) {
            // Empty value handling
            if (!value) {
                return allowPlaceholders;
            }

            // Placeholder handling - only accept if allowPlaceholders is true
            if (value === 'N/A' || value === 'Unknown') {
                return allowPlaceholders;
            }

            // Handle comma-separated values (for multi-select)
            if (value.includes(',')) {
                const values = value.split(',').map(v => v.trim()).filter(v => v);
                // All values must be valid
                return values.every(v => {
                    // Check for placeholders in individual values
                    if ((v === 'N/A' || v === 'Unknown') && !allowPlaceholders) {
                        return false;
                    }
                    return options.includes(v);
                });
            }

            // Single value
            return options.includes(value.trim());
        }

        // Create validation indicator HTML
        function getValidationIndicator(isValid) {
            if (isValid) {
                return '';
            }
            return '<span class="validation-error" title="Invalid value - click edit to fix">‚ùå</span>';
        }

        // Toggle edit mode for BookTitle, Genre, Category, and Language
        function toggleEditMode(isbn) {
            const row = document.getElementById('row-' + isbn);
            if (!row) return;

            const titleCell = row.querySelector('.editable-title');
            const genreCell = row.querySelectorAll('td')[3]; // Genre column
            const categoryCell = row.querySelectorAll('td')[4]; // Category column
            const languageCell = row.querySelector('.editable-language');
            const editBtn = row.querySelector('.edit-btn');

            const isEditing = titleCell.classList.contains('editing');

            if (isEditing) {
                // Save mode - save the changes
                saveISBNEdit(isbn, titleCell, genreCell, categoryCell, languageCell, editBtn, row);
            } else {
                // Edit mode - make fields editable
                enableEditMode(titleCell, genreCell, categoryCell, languageCell, editBtn, row);
            }
        }

        // Create dropdown HTML (for Language - single select)
        function createDropdown(options, currentValue, id) {
            let html = `<select id="${id}" style="width: 100%; padding: 8px; font-size: 14px; border: 2px solid #2e8b57; border-radius: 4px; background: #fff9e6;">`;

            // Add current value if not in options
            if (currentValue && !options.includes(currentValue) && currentValue !== 'N/A' && currentValue !== 'Unknown') {
                html += `<option value="${currentValue}" selected>${currentValue} (current)</option>`;
            }

            options.forEach(option => {
                const selected = option === currentValue ? 'selected' : '';
                html += `<option value="${option}" ${selected}>${option}</option>`;
            });

            html += `</select>`;
            return html;
        }

        // Create multi-select dropdown HTML (for Genre and Category)
        function createMultiSelectDropdown(options, currentValues, id, fieldName) {
            // Parse current values (comma-separated)
            const selectedValues = currentValues ? currentValues.split(',').map(v => v.trim()).filter(v => v && v !== 'N/A' && v !== 'Unknown') : [];

            let html = `<div class="multi-select-container" id="${id}-container">`;
            html += `<div class="multi-select-checkboxes">`;

            // Create checkbox for each option
            options.forEach(option => {
                const isChecked = selectedValues.includes(option);
                const checkboxId = `${id}-${option.replace(/[^a-zA-Z0-9]/g, '-')}`;
                html += `
                    <label class="multi-select-checkbox">
                        <input type="checkbox" id="${checkboxId}" value="${option}" ${isChecked ? 'checked' : ''}
                            onchange="updateMultiSelectTags('${id}', '${fieldName}')">
                        <span class="checkbox-label">${option}</span>
                    </label>
                `;
            });

            html += `</div>`;
            html += `<div class="multi-select-tags" id="${id}-tags">`;

            // Create tags for selected values
            selectedValues.forEach(value => {
                html += `
                    <div class="selected-tag">
                        <span>${value}</span>
                        <span class="remove-tag" onclick="removeMultiSelectTag('${id}', '${value}', '${fieldName}')">&times;</span>
                    </div>
                `;
            });

            html += `</div>`;
            html += `</div>`;

            return html;
        }

        // Update multi-select tags when checkbox changes
        function updateMultiSelectTags(id, fieldName) {
            const container = document.getElementById(`${id}-container`);
            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            const selectedValues = Array.from(checkboxes).map(cb => cb.value);
            const tagsContainer = document.getElementById(`${id}-tags`);

            // Clear existing tags
            tagsContainer.innerHTML = '';

            // Create tag for each selected value
            selectedValues.forEach(value => {
                const tag = document.createElement('div');
                tag.className = 'selected-tag';
                tag.innerHTML = `
                    <span>${value}</span>
                    <span class="remove-tag" onclick="removeMultiSelectTag('${id}', '${value}', '${fieldName}')">&times;</span>
                `;
                tagsContainer.appendChild(tag);
            });
        }

        // Remove a tag from multi-select
        function removeMultiSelectTag(id, value, fieldName) {
            const container = document.getElementById(`${id}-container`);
            const checkboxId = `${id}-${value.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const checkbox = document.getElementById(checkboxId);

            if (checkbox) {
                checkbox.checked = false;
                updateMultiSelectTags(id, fieldName);
            }
        }

        // Get selected values from multi-select as comma-separated string
        function getMultiSelectValues(id) {
            const container = document.getElementById(`${id}-container`);
            if (!container) return '';

            const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value).join(', ');
        }

        // Enable edit mode on cells
        function enableEditMode(titleCell, genreCell, categoryCell, languageCell, editBtn, row) {
            // Store original values
            const originalTitle = titleCell.textContent.trim();
            const originalGenre = genreCell.textContent.replace(/‚ùå/g, '').trim(); // Remove validation error icon
            const originalCategory = categoryCell.textContent.replace(/‚ùå/g, '').trim();
            const originalLanguage = languageCell.textContent.replace(/‚ùå/g, '').trim();

            titleCell.dataset.original = originalTitle;
            genreCell.dataset.original = originalGenre;
            categoryCell.dataset.original = originalCategory;
            languageCell.dataset.original = originalLanguage;

            // Make title contenteditable
            titleCell.contentEditable = true;
            titleCell.classList.add('editing');

            // Replace Genre with multi-select dropdown
            genreCell.innerHTML = createMultiSelectDropdown(GENRE_OPTIONS, originalGenre, 'genre-edit-' + row.dataset.isbn, 'genre');
            genreCell.classList.add('editing');

            // Replace Category with multi-select dropdown
            categoryCell.innerHTML = createMultiSelectDropdown(CATEGORY_OPTIONS, originalCategory, 'category-edit-' + row.dataset.isbn, 'category');
            categoryCell.classList.add('editing');

            // Replace Language with single-select dropdown
            languageCell.innerHTML = createDropdown(LANGUAGE_OPTIONS, originalLanguage, 'language-edit-' + row.dataset.isbn);
            languageCell.classList.add('editing');

            // Change icon to save
            editBtn.textContent = 'üíæ';
            editBtn.style.color = '#2196F3';

            // Focus on title field
            titleCell.focus();

            console.log('üìù Edit mode enabled for row with multi-select dropdowns');
        }

        // Save edited ISBN data back to ISBN_List
        async function saveISBNEdit(isbn, titleCell, genreCell, categoryCell, languageCell, editBtn, row) {
            const newTitle = titleCell.textContent.trim();

            // Get values from multi-select dropdowns (Genre and Category)
            const newGenre = getMultiSelectValues('genre-edit-' + isbn) || genreCell.dataset.original;
            const newCategory = getMultiSelectValues('category-edit-' + isbn) || categoryCell.dataset.original;

            // Get value from single-select dropdown (Language)
            const newLanguage = document.getElementById('language-edit-' + isbn)?.value || languageCell.dataset.original;

            const originalTitle = titleCell.dataset.original;
            const originalGenre = genreCell.dataset.original;
            const originalCategory = categoryCell.dataset.original;
            const originalLanguage = languageCell.dataset.original;

            // Check if anything changed
            if (newTitle === originalTitle && newGenre === originalGenre &&
                newCategory === originalCategory && newLanguage === originalLanguage) {
                // No changes, just exit edit mode
                disableEditMode(titleCell, genreCell, categoryCell, languageCell, editBtn, originalGenre, originalCategory, originalLanguage);
                return;
            }

            // Validate title is not empty
            if (!newTitle || newTitle === '') {
                showAlert('‚ö†Ô∏è Book Title cannot be empty!', 'error');
                titleCell.textContent = originalTitle;
                return;
            }

            // Disable edit mode first
            disableEditMode(titleCell, genreCell, categoryCell, languageCell, editBtn, newGenre, newCategory, newLanguage);

            // Show saving indicator
            editBtn.textContent = '‚è≥';
            editBtn.style.color = '#FFA500';

            const dataToSend = {
                action: 'updateISBN',
                isbn: isbn,
                bookTitle: newTitle,
                genre: newGenre,
                category: newCategory,
                language: newLanguage
            };

            console.log('Updating ISBN entry:', dataToSend);

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(dataToSend),
                    redirect: 'follow'
                });

                const result = await response.json();
                console.log('Update result:', result);

                if (result.success) {
                    showAlert('‚úÖ Book details updated successfully!', 'success');

                    // Update the row's data attributes
                    row.dataset.title = newTitle;
                    row.dataset.genre = newGenre;
                    row.dataset.category = newCategory;
                    row.dataset.language = newLanguage;

                    // Reset icon to edit
                    editBtn.textContent = '‚úèÔ∏è';
                    editBtn.style.color = '#2e8b57';

                    // Refresh table to sync with Google Sheets
                    setTimeout(() => {
                        loadISBNList();
                    }, 500);
                } else {
                    showAlert('Failed: ' + result.message, 'error');

                    // Revert to original values
                    titleCell.textContent = originalTitle;
                    genreCell.innerHTML = `<strong>${originalGenre}</strong>`;
                    categoryCell.textContent = originalCategory;
                    languageCell.textContent = originalLanguage;

                    // Reset icon to edit
                    editBtn.textContent = '‚úèÔ∏è';
                    editBtn.style.color = '#2e8b57';
                }
            } catch (error) {
                console.error('Error updating ISBN entry:', error);
                showAlert('Error updating book details', 'error');

                // Revert to original values
                titleCell.textContent = originalTitle;
                genreCell.innerHTML = `<strong>${originalGenre}</strong>`;
                categoryCell.textContent = originalCategory;
                languageCell.textContent = originalLanguage;

                // Reset icon to edit
                editBtn.textContent = '‚úèÔ∏è';
                editBtn.style.color = '#2e8b57';
            }
        }

        // Disable edit mode on cells
        function disableEditMode(titleCell, genreCell, categoryCell, languageCell, editBtn, newGenre, newCategory, newLanguage) {
            // Remove contenteditable from title
            titleCell.contentEditable = false;
            titleCell.classList.remove('editing');

            // Validate and add indicators for Genre (strict - no placeholders)
            const isGenreValid = isValidDropdownValue(newGenre, GENRE_OPTIONS, false);
            const genreIndicator = getValidationIndicator(isGenreValid);
            const genreClass = isGenreValid ? '' : 'invalid-field';

            // Replace Genre multi-select with text (comma-separated)
            genreCell.innerHTML = `<strong>${newGenre}</strong>${genreIndicator}`;
            genreCell.className = genreClass; // Reset classes
            genreCell.classList.remove('editing');

            // Validate and add indicators for Category (strict - no placeholders)
            const isCategoryValid = isValidDropdownValue(newCategory, CATEGORY_OPTIONS, false);
            const categoryIndicator = getValidationIndicator(isCategoryValid);
            const categoryClass = isCategoryValid ? '' : 'invalid-field';

            // Replace Category multi-select with text (comma-separated)
            categoryCell.innerHTML = newCategory + categoryIndicator;
            categoryCell.className = categoryClass; // Reset classes
            categoryCell.classList.remove('editing');

            // Validate and add indicators for Language (allow placeholders)
            const isLanguageValid = isValidDropdownValue(newLanguage, LANGUAGE_OPTIONS, true);
            const languageIndicator = getValidationIndicator(isLanguageValid);
            const languageClass = isLanguageValid ? '' : 'invalid-field';

            // Replace Language dropdown with text
            languageCell.innerHTML = newLanguage + languageIndicator;
            languageCell.className = 'editable-language ' + languageClass; // Keep editable-language class
            languageCell.classList.remove('editing');

            // Change icon back to edit
            editBtn.textContent = '‚úèÔ∏è';
            editBtn.style.color = '#2e8b57';

            console.log('üìù Edit mode disabled');
        }

        // Add book to table optimistically (before save confirmation)
        function addBookToTableOptimistic(book) {
            const tableContainer = document.getElementById('isbnTableContainer');
            let table = tableContainer.querySelector('.isbn-table tbody');

            if (!table) {
                // Table doesn't exist yet, create an empty table structure
                console.log('üìä Creating empty table structure for first book');

                const tableHTML = `
                    <table class="isbn-table">
                        <thead>
                            <tr>
                                <th>ISBN</th>
                                <th>Book Title</th>
                                <th>Author</th>
                                <th>Genre</th>
                                <th>Category</th>
                                <th>Language</th>
                                <th style="width: 60px; text-align: center;">Edit</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                `;

                tableContainer.innerHTML = tableHTML;
                table = tableContainer.querySelector('.isbn-table tbody');

                // Don't show slider yet - wait until first book is added
                console.log('‚úì Empty table created, will add first book now');
            }

            // Check if book already exists
            const existingRow = document.getElementById('row-' + book.isbn);
            if (existingRow) {
                console.log('Book already in table, highlighting it');
                existingRow.style.animation = 'flashIn 0.5s ease-in-out';
                setTimeout(() => {
                    existingRow.style.animation = '';
                }, 500);
                return;
            }

            // Use mapped genre from book object
            const mappedGenre = book.genre || 'Unknown';

            // Get category from book (default to N/A)
            const category = 'N/A';

            // Validate dropdown values
            // Genre and Category: strict validation (no placeholders allowed)
            const isGenreValid = isValidDropdownValue(mappedGenre, GENRE_OPTIONS, false);
            const isCategoryValid = isValidDropdownValue(category, CATEGORY_OPTIONS, false);
            // Language: allow placeholders
            const isLanguageValid = isValidDropdownValue(book.language, LANGUAGE_OPTIONS, true);

            // Add validation indicators
            const genreIndicator = getValidationIndicator(isGenreValid);
            const categoryIndicator = getValidationIndicator(isCategoryValid);
            const languageIndicator = getValidationIndicator(isLanguageValid);

            // Add invalid-field class if validation fails
            const genreClass = isGenreValid ? '' : 'invalid-field';
            const categoryClass = isCategoryValid ? '' : 'invalid-field';
            const languageClass = isLanguageValid ? '' : 'invalid-field';

            // Create new row with loading indicator
            const newRow = document.createElement('tr');
            newRow.id = 'row-' + book.isbn;
            newRow.dataset.isbn = book.isbn;
            newRow.dataset.title = book.title;
            newRow.dataset.author = book.authors;
            newRow.dataset.genre = mappedGenre;
            newRow.dataset.category = category;
            newRow.dataset.language = book.language;
            newRow.classList.add('optimistic-row');
            newRow.style.opacity = '0.6'; // Show it's pending

            newRow.innerHTML = `
                <td>${book.isbn || 'N/A'}</td>
                <td class="editable-title"><strong>${book.title || 'Unknown Title'}</strong></td>
                <td>${book.authors || 'N/A'}</td>
                <td class="${genreClass}"><strong>${mappedGenre}</strong>${genreIndicator}</td>
                <td class="${categoryClass}">${category}${categoryIndicator}</td>
                <td class="editable-language ${languageClass}">${book.language || 'N/A'}${languageIndicator}</td>
                <td style="text-align: center;">
                    <span style="color: #FFA500; font-size: 16px;">‚è≥</span>
                </td>
            `;

            // Add to top of table with animation
            table.insertBefore(newRow, table.firstChild);
            newRow.style.animation = 'flashIn 0.3s ease-in-out';

            // Update book count (but don't show slider yet - wait for backend confirmation)
            const bookCount = table.querySelectorAll('tr').length;
            console.log('üìä Current optimistic book count:', bookCount);

            // Don't show slider during optimistic add
            // Slider will appear only after first book is saved and loaded from Google Sheets

            console.log('‚ú® Added book to table optimistically (slider hidden until backend save confirms)');
        }

        // Confirm optimistic book after successful save
        function confirmOptimisticBook(isbn) {
            const row = document.getElementById('row-' + isbn);
            if (!row) return;

            row.classList.remove('optimistic-row');
            row.style.opacity = '1';

            // Replace loading indicator with edit button
            const editCell = row.querySelector('td:last-child');
            editCell.innerHTML = `
                <button class="edit-btn" onclick="toggleEditMode('${isbn}')"
                    style="background: none; border: none; cursor: pointer; font-size: 18px; color: #2e8b57; padding: 5px;">
                    ‚úèÔ∏è
                </button>
            `;

            row.style.animation = 'successPulse 0.5s ease-in-out';
            setTimeout(() => {
                row.style.animation = '';
            }, 500);

            console.log('‚úÖ Confirmed optimistic book:', isbn);
        }

        // Remove optimistic book if save failed
        function removeOptimisticBook(isbn) {
            const row = document.getElementById('row-' + isbn);
            if (!row) return;

            row.style.animation = 'fadeOut 0.3s ease-in-out';
            setTimeout(() => {
                row.remove();

                // Update book count
                const table = document.querySelector('.isbn-table tbody');
                if (table) {
                    const bookCount = table.querySelectorAll('tr').length;
                    const bookCountEl = document.getElementById('bookCount');
                    if (bookCountEl) {
                        bookCountEl.textContent = bookCount;
                    }

                    // Hide slide section if no books
                    if (bookCount === 0) {
                        document.getElementById('slideToSaveSection').style.display = 'none';
                    }
                }
            }, 300);

            console.log('‚ùå Removed optimistic book:', isbn);
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            checkIframePermissions();
            // Load ISBN_List on page load
            loadISBNList();
        });
    </script>
</body>
</html>
